[TOC]

# 函数介绍

## Img = mat2imgcell(D, height, width, ImgFormat)

### 输入

- 图像数组D：每一列代表一个图像样本
- height：设定输出每一幅图像的高度
- width：设定输出每一幅图像的宽度
- ImgFormat：设定输入图像的格式
  1. gray：灰度图
  2. color
  3. color2THREEgray

### 输出

-  Img：输出一个列元胞数组，列数等于图像数组样本个数，每一个cell为设定为height-by-width的图像。第n个cell对应图像数组的第n列。

### 功能介绍

利用reshape函数对图像数组D的每一列进行height和width的设定，存为Img中的一个cell。

## B = im2colstep(A, [N1 N2], [S1 S2])

### 输入

- A：一副图像
- [N1 N2]：要在图像A上进行子区域提取的块大小，单位长度均为像素
- 子区域提取的间隔步长，默认为[1 1]。

### 输出

- B：行数为N1-by-N2，列数为提取子区域块数的数组。

### 功能介绍

在图像A上进行子区域像素提取时，不会对A的边界进行零元素扩充(提取的子区域块数小于A的像素总数)。第一个进行提取的子区域是A(1:N1,1:N2)，然后按照列主导的方式，依据步长[S1 S2]进行下一子区域提取，即A((1:N1)+i * S1, (1:N2)+j * S2)(First i, then j)。

__B = im2colstep(A, [N1 N2 N3], [S1 S2 S3])__可以扩展到3维的情形。

## im = im2col_mean_removal(varargin)

### 输入

- varargin{1}：输入图像
- varargin{2}：提取子区域块大小[N1 N2]
- varargin{3}：提取子区域步长[S1 S2]

### 输出

- im：行数为N1-by-N2，列数为子区域块数。对输入图像遍历采样子区域形成的该图像的子区域数组。

### 功能介绍

利用__im2colstep__函数获得图像的子区域数组，然后利用mean函数对子区域数组的列求均值(对应获得各个区域的均值)，再利用bsxfun函数对子区域数组减去该均值(各个子区域减去该子区域的均值)，对应到对形成的特征进行PCA操作时减去均值的步骤。如果存在多个通道，则每个通道大小为[N1-by-N2]-by-提取子区域数，多个通道按列依次排列输出。

## im = im2col_general(varargin)

### 输入

- varargin{1}：输入图像
- varargin{2}：提取子区域块大小[N1 N2]
- varargin{3}：提取子区域步长[S1 S2]

### 输出

- im：行数为N1-by-N2，列数为子区域块数。对输入图像遍历采样子区域形成的该图像的子区域数组。

### 功能介绍

相对于__im2col_mean_removal__函数，少了去均值的操作，转置操作是一致的，输出的形式也一致。借助于__im2colstep__函数，对该函数进行封装，以处理多通道的情况。

## D = dist_cosine(A, B)

### 输入

- A，B：样本矩阵，每一列代表一个样本

### 输出

- 距离对矩阵，行数等于A矩阵样本数，列数等于B矩阵样本数，每一行代表样本矩阵A的样本与样本矩阵B各个样本之间的cosine距离。

### 功能介绍

首先对要计算的样本对的维度数是否一样进行检查，利用error函数输出错误。然后利用bsxfun函数对样本矩阵A和B的每一列样本长度平方(cosine距离为夹角与向量长度无关，对长度平方在计算时可以省去除以分母的步骤)。最后取样本矩阵A的每一列转置和样本矩阵B相乘(向量内积)，然后利用ones函数相减得到cosine距离(范围为[0,2])。

## V = PCA_FilterBank(InImg, PatchSize, NumFilters)

### 输入

- InImg：列元胞数组，每一个cell代表一个图像，要么是一个矩阵(Gray)或者是tensor(RGB)
- PatchSize：提取子区域的块大小
- NumFilters：卷积核个数

### 输出

- V：卷积核，行数代表卷积核按列展开，列数代表卷积核个数

### 功能介绍

该函数用于在给定子区域块大小和卷积核个数(PCA降维维数)之后，在输入图像元胞数组上计算获得PCA卷积核V(算法见论文)。

首先为了应对具有很多训练样本的情况，利用min函数取图像个数与100000之间的最小值作为训练样本数，然后对图像利用randperm函数进行随机排列，选取前训练样本数个作为训练样本(下标对于矩阵和for循环的操作)；然后对于输入的每一幅训练样本图像(利用随机排列的下标获取)，利用__im2col_mean_removal__函数获得该图像的子区域去均值数组im，im*im'获得该图像子区域数组的Scatter Matrix；之后将所有训练样本图像子区域数组的Scatter Matrix相加，除以训练样本数-by-Patchsize-by-Patchsize获得最后的协方差矩阵；利用eig函数获得协方差矩阵的特征值与特征向量，利用sort函数对特征值由大到小排序，对应截取NumFilters对应的特征向量构成V。

## [OutImg, OutImgIdx] = PCA_output(InImg, InImgIdx, PatchSize, NumFilters, V)

### 输入

- InImg：列元胞数组，每一个cell代表一个图像，要么是一个矩阵(Gray)或者是tensor(RGB)
- InImgIdx：列标签数组，标记每一幅图像，用于追踪标记同一副图像
- PatchSize：提取子区域的块大小
- NumFilters：卷积核个数
- V：PCA卷积核

### 输出

- OutImg：列元胞数组，每一个cell代表一个图像
- OutImgIdx：列标签数组，标记每一幅图像，用于追踪标记同一副图像，同一副图像标签相同

### 功能介绍

该函数利用输入的每一个PCA卷积核(V每一列)，对输入的每一幅图像进行卷积操作，获得与输入图像尺寸相同的卷积图像，成为输出OutImg中的一个cell，OutImgIdx标签标记同一副图像。

首先利用zeros函数和PatchSize对输入原图像边界进行零元素扩充(保证卷积图像与原图像尺寸大小相同)，然后利用__im2col_mean_removal__函数对输入图像提取子区域并去均值(不去均值效果较差，见论文)，获得子区域数组(方便之后在各个子区域上的卷积操作)，之后利用不同卷积核对子区域数组进行卷积操作，操作借助于reshape函数、矩阵转置和乘积操作获得与输入图像同样大小的卷积图像，输出为OutImg中的一个cell；利用kron函数获得OutImgIdx标签数组。

## X = Heaviside(X)

### 输入

- X：一副图像

### 输出

- X：二值化后的图像

### 功能介绍

利用sign函数对图像逐个像素进行二值化操作(1,-1)；利用逻辑下标操作将-1的部分置为0。

## [f BlkIdx] = HashingHist(PCANet, ImgIdx, OutImg)

### 输入

- PCANet：PCANet参数(struct结构)
  - .NumStages：PCANet层数
  - .PatchSize：不同层数对应的子区域(正方形)大小，例如[5, 3]，5对应第一层子区域大小为5-by-5，3对应第二层子区域大小为3-by-3
  - .NumFilters：不同层数对应的卷积核个数，格式同上
  - .HistBlockSize：局部直方图提取的区域块大小
  - .BlkOverLapRatio：不同直方图区域可以覆盖的比例，例如0代表没有覆盖，0.3代表30%的区域被覆盖
  - .Pyramid：空间金字塔匹配，例如[1, 2, 4]，[ ]代表不采用金字塔
- ImgIdx：列向量，输入卷积图像OutImg标签，同一副卷积图像标签相同
- OutImg：列元胞数组，最后一阶段卷积操作得到的卷积图像元胞数组，每一个cell对应一个卷积图像

### 输出

- f：利用PCANet获得的原始图像的PCANet特征，每一列代表原始每一幅图像的特征，列数为原始图像个数
- BlkIdx：代表每个直方图特征的计算来自于图像中第几块直方图子区域，按照压缩图像个数依次排列。这里和输出f的特征意义不匹配。

### 功能介绍

该函数利用预先确定的PCANet网络参数，将最后一层卷积图像OutImg根据ImgIdx下标，进行Hashing和Local histogram操作，生成PCANet特征(对应f的每一列)，输出f的行数与原始图像个数相同(与原始图像对应)。

#### Hashing

利用max函数获得原始图像个数。将与最后一层卷积核相对应的图像首先利用__Heaviside__函数进行二值化操作，然后将二值化后的每一幅图像的每一个像素作为二进制位数的一位(位数由最后一层卷积核个数确定)，由高到低赋予权重，然后压缩加和为一副图像中对应像素的十进制数值(范围[0, 2^(最后一层卷积核个数)-1])。

#### Local Histogram

利用find函数获得一副原始图像在卷积图像标签数组ImgIdx中的位置(下标范围)，经过Hashing压缩操作以后，计算得到的剩余图像个数即是与这幅原始图像对应的，需要提取局部直方图特征的图像个数`Num0s`。在每一幅原始图像的这`Num0s`个图像中，进行提取直方图特征的计算。首先利用`.BlkOverLapRatio`参数计算得到压缩图像子区域移动的步长，然后利用__im2colgeneral__函数(参数为压缩后的图像，`.HistBlockSize`，步长对)提取得到压缩图像的直方图子区域，之后利用histc函数(bins范围设置为[0:2^(最后一层卷积核个数)-1])在每个直方图子区域上得到直方图特征(在每一列上计算得到直方图特征，行数代表直方图子区域个数)，利用sparse函数将压缩图像的直方图特征转化为一个稀疏矩阵。__注意，将得到直方图特征每一列的每个bin上的像素个数进行扩大，使得该列直方图每个bin上的像素个数总和为256__。

由此，我们得到了该原始图像的`Num0s`个压缩图像各自对应的直方图特征，首先将这个`Num0s`个直方图特征(cell数组)展开形成数组(行数为bins，列数为`Num0s`-by-每幅压缩图像提取的直方图子区域个数)，转置，然后再向量化(__注意，这里的向量化操作是将直方图每一个bin所对应的每个压缩图像的所有直方图子区域，总共`Num0s`个压缩图像，展开为输出列向量中的一列，特征的维度顺序不会对分类结果造成影响__)，得到该原始图像最后的PCANet特征，存为对应输出f中的一个cell。

最后将cell数组f(每一个cell对应一个原始图像)，展开为稀疏矩阵，每一列代表一个图像的特征。

## [f V BlkIdx] = PCANet_train(InImg, PCANet, IdtExt)

### 输入

- PCANet：PCANet参数(struct结构)
- InImg：列元胞数组，每一个cell代表一副图像
- IdtExt：模式选取，1代表特征提取，0代表其他

### 输出

- f：输入训练图片元胞数组InImg经由PCANet提取得到的对应特征
- V：给定PCANet结构参数，由训练图片元胞数组InImg计算得到的不同层的卷积核；列元胞数组，每一个cell代表当前层获得的卷积核。
- BlkIdx：代表每个直方图特征的计算来自于图像中第几块直方图子区域，按照压缩图像个数依次排列。

### 功能介绍

该函数利用输入训练图片元胞数组InImg，给定PCANet结构参数后，计算得到不同层对应的卷积核，以及InImg经过PCANet转化后的特征。

利用__PCA_FiltersBank__函数和__PCA_output__函数首先获得不同层数的卷积核，以及最后一层卷积操作之前的卷积图像。由于卷积操作随着层数呈指数增长，在进行最后一层卷积操作时，我们采用for循环，借助__PCA_output__函数，针对每幅图像进行最后一层的卷积操作，然后借助__HashingHist__函数得到该图像最后的PCANet特征。最后将得到的所有图像的PCANet特征(对应元胞数组f的每一个cell)，展开为一个稀疏矩阵。

## [f BlkIdx] = PCANet_FeaExt(InImg, V, PCANet)

### 输入

- PCANet：PCANet参数(struct结构)
- V：给定PCANet不同层的卷积核，列元胞数组，每一层对应相应行的cell
- InImg：输入需要提取PCANet特征的原始图像，元胞数组，每一个cell对应一个图像

### 输出

- f：与InImg相对应的，由PCANet提取得到的特征；每一列代表一个图像特征，行数与原始图像个数相同
- BIkIdx：代表每个直方图特征的计算来自于图像中第几块直方图子区域，按照压缩图像个数依次排列

### 功能介绍

该函数将原始输入图像元胞数组InImg，在给定PCANet结构参数和每层卷积核V的情况下，首先借助于__PCA_output__函数，按照不同层数循环进行卷积操作，得到最后一层的卷积图像；然后将最后一层的卷积图像借助__HashingHist__函数形成最后的PCANet特征。

# 分类

## SVM

利用[liblinear](https://www.csie.ntu.edu.tw/~cjlin/liblinear/)函数包作为线性分类器进行SVM分类。利用PCANet获取的特征不作降维，直接进行训练测试。

## 最近邻

利用PCANet获取的特征，首先利用svds函数进行降维，获取到投影矩阵(特征向量)，然后借助于WPCA的理论，与人脸相关的特征与方差较大(特征值最大)的几个方向呈负相关，因此对方差较大的特征向量赋予[1/对应特征值]的权重(与权重相乘)，形成投影矩阵进行投影。然后采用cosine距离和最近邻匹配进行分类。

# SVD与PCA的关系

- https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html
- 张宏鑫课件：component_analysis

# 参考工作

- http://mx.nthu.edu.tw/~tsunghan/Source%20codes.html